#!/usr/bin/tclsh
#############################################################################
#   puse/pkey/plic                                                          #
#                                                                           #
# Script for management of Gentoo emerge flag files.                        #
# Respectful of file layout (category blocks, comments, blanks, ...).       #
# Handles:                                                                  #
#   * USE flags in package.use when called as 'puse'                        #
#   * keywords in package.accept_keywords when called as 'pkey'             #
#   * licenses in package.license when called as 'plic'                     #
#                                                                           #
# Atom names are parsed as per PMS EAPI 5.
#                                                                           #
# History:                                                                  #
#   v0.2    Diversification: handle keywords and licenses                   #
#   v0.1    Initial version: handle USE flags only                          #
#############################################################################


#############################################################################
#############################################################################
#
# Packages
#
#############################################################################
#############################################################################

lappend auto_path [file normalize [file join [file dirname $::argv0] ../../tcl]]

package require debug
package require getopt


#############################################################################
#############################################################################
#
# Globals
#
#############################################################################
#############################################################################

# Version number
set version "0.2"

# Operating mode (set by [SetupMode])
set mode ""

# Flag description (used in messages ; set by [SetupMode])
set flagdesc ""
# Flagspec status regexp
set flagstatusrx {[?%+-]}
# Flagspec regexp capturing status (+-?%) and flag (set by [SetupMode])
set flagrx ""

# Path to file (set by [SetupMode])
set path ""

# Verbosity level
set verbose 0

# Resulting flags
set flags ""
# Flag query results
set query ""
# Boolean holding whether only queries were done (no set/unset/reset)
set queryonly 1

# Atom regexps
set constraint_rx {(?:<|<=|=|>=|>)}
set category_rx {(?:[a-zA-Z0-9_][a-zA-Z0-9_+.-]*)}
set package_rx {(?:[a-zA-Z0-9_][a-zA-Z0-9_+]*(?:-(?:[a-zA-Z0-9_+]*-)*[a-zA-Z_+]*)?)}
set version_rx {(?:[0-9]+(?:\.[0-9]+)*[a-z]?(?:_(?:alpha|beta|pre|rc|p)[0-9]*)?(?:-r[0-9]+)?)}
set use_rx {(?:[a-zA-Z0-9][a-zA-Z0-9@_+-]*)}
set keyword_rx {(?:~?[a-zA-Z0-9_][a-zA-Z0-9_-]*)}
set license_rx {(?:[[:graph:]]+)}

#############################################################################
#############################################################################
#
# Procedures
#
#############################################################################
#############################################################################

#############################################################################
# Get the script name.
#
# Arguments: NONE
#
# Globals: NONE
#
# Variables: NONE
#
# Return:
#   script basename (no leading path, no trailing .tcl)
#############################################################################
proc scriptName {} {
    # Strip the path
    set base [file tail $::argv0]
    # Strip any trailing .tcl extension
    if {[file extension $base] eq ".tcl"} {
        set base [file rootname $base]
    }
    # Return the resulting basename
    return $base
}

#############################################################################
# Print an error message and bail out.
#
# Arguments:
#   message     error message
#   code        return code (default: 1)
#   prefix      optional prefix to the error message (default: "Error: ")
#
# Globals: NONE
#
# Variables: NONE
#
# Return: NONE
#############################################################################
proc die {message {code 1} {prefix "Error: "}} {
    # Print the message
    puts stderr ${prefix}${message}
    # Exit with the given return code
    exit $code
}

#############################################################################
# Escape a string for use in a regexp pattern.
#
# Arguments:
#   str     string to escape
#
# Globals: NONE
#
# Variables: NONE
#
# Return:
#   escaped string that can safely be used as a fixed string in a regexp
#############################################################################
proc reEscape {str} {
    regsub -all {\W} $str {\\&}
}

#############################################################################
# Remove indices from a list.
#
# Arguments:
#   listVar     list variable to strip indices from
#   indices     indices to strip from the list
#
# Globals: NONE
#
# Variables: NONE
#
# Return: NONE
#############################################################################
proc lremove {listVar indices} {
    upvar 1 $listVar list
    # Sort the indices in decreasing order (so that indices get removed from
    # the end of the list first and don't impact removal of other indices)
    set indices [lsort -integer -decreasing $indices]
    # Remove each index
    foreach i $indices {
        set list [lreplace $list $i $i]
    }
}

#############################################################################
# Setup the script variables according to the given operating mode.
# If the mode name is not valid, the default 'use' mode will be selected.
#
# Arguments:
#   m           user operating mode (possibly invalid)
#
# Globals:
#   mode            selected operating mode
#   flagdesc        flag description
#   flagstatusrx    flag status regexp
#   flagrx          flagspec regexp
#   path            path to the default target file of the mode
#   use_rx          USE flag regexp
#   keyword_rx      keyword regexp
#   license_rx      license regexp
#
# Variables: NONE
#
# Return:
#   boolean indicating whether the given mode name was valid
#############################################################################
proc SetupMode {m} {
    global mode
    global flagdesc
    global flagstatusrx
    global flagrx
    global path
    global use_rx
    global keyword_rx
    global license_rx

    # Switch according to the given mode, defaulting to "use" mode
    switch $m {
        "key" {
            # Remember the operating mode
            set mode "key"
            # Setup variables
            set path "/etc/portage/package.accept_keywords"
            set flagdesc "keyword"
            set flagrx "^(${flagstatusrx}?)(${keyword_rx})\$"
        }

        "lic" {
            # Remember the operating mode
            set mode "lic"
            # Setup variables
            set path "/etc/portage/package.license"
            set flagdesc "license"
            set flagrx "^(${flagstatusrx}?)(${license_rx})\$"
        }

        "use" -
        default {
            # Remember the operating mode
            set mode "use"
            # Setup variables
            set path "/etc/portage/package.use"
            set flagdesc "USE flag"
            set flagrx "^(${flagstatusrx}?)(${use_rx})\$"
        }
    }

    # Return whether the given mode name was valid
    return [expr {$mode ne $m}]
}

#############################################################################
# Parse a flagspec and return the status and flag name.
#
# Arguments:
#   flagspec    flagspec to parse
#   statusVar   status variable
#   flagVar     flag variable
#
# Globals:
#   flagrx      flagspec regexp
#
# Variables: NONE
#
# Return:
#   boolean indicating success or failure of parse
#############################################################################
proc ParseFlagspec {flagspec statusVar flagVar} {
    global flagrx
    upvar 1 $statusVar status $flagVar flag

    # Parse the flagspec according to the mode's regexp and return the result
    return [regexp -- $flagrx $flagspec -> status flag]
}

#############################################################################
# Compare two flagspecs alphabetically, ignoring leading symbols.
#
# Arguments:
#   fs1     first flagspec
#   fs2     second flagspec
#
# Globals: NONE
#
# Variables: NONE
#
# Return:
#   an integer less than, equal to, or greater than zero if the first
#   flagspec is to be considered less than, equal to, or greater than the
#   second, respectively
#############################################################################
proc CompareFlags {fs1 fs2} {
    # Get the flag names
    ParseFlagspec $fs1 - f1
    ParseFlagspec $fs2 - f2
    # Compare them
    return [string compare $f1 $f2]
}

#############################################################################
# Update a list of flags according to a list of flagspecs.
#
# Arguments:
#   flags       list of flags
#   flagspecs   list of flagspecs
#
# Globals:
#   query       holds the result of query flagspecs
#   queryonly   holds whether only queries were done on the flags
#
# Variables: NONE
#
# Return:
#   updated list of flags
#############################################################################
proc UpdateFlags {flags flagspecs} {
    global query queryonly

    # Process each flagspec
    foreach spec $flagspecs {
        # Parse the flagspec
        if {![ParseFlagspec $spec action flag]} {
            die "wrong format for flag: $spec" 2
        }
        if {$action eq ""} {
            set action "+"
        }
        # Search for the flag
        set iflag [lsearch -all -regexp $flags "^\[+-\]?[reEscape $flag]\$"]

        # Process the flag according to its action
        switch -- $action {
            + {
                # Set the flag
                # Remove all occurences of the flag
                lremove flags $iflag
                # Append the flagspec
                lappend flags $flag
                # By the way, now we're not just querying
                set queryonly 0
            }

            - {
                # Unset the flag
                # Remove all occurences of the flag
                lremove flags $iflag
                # Append the flagspec
                lappend flags -$flag
                # By the way, now we're not just querying
                set queryonly 0
            }

            % {
                # Reset the flag
                # Remove all occurences of the flag
                lremove flags $iflag
                # By the way, now we're not just querying
                set queryonly 0
            }

            ? {
                # Query the flag
                # Remove all occurences of the flag but the last
                lremove flags [lrange $iflag 0 end-1]
                # Append the state of the flag to the query results
                if {[llength $iflag] > 0} {
                    lappend query [lindex $flags [lindex $iflag end]]
                } else {
                    lappend query %$flag
                }
            }
        }
    }

    # Sort and return the flags
    return [lsort -command CompareFlags $flags]
}

#############################################################################
# Parse an atom line.
#
# Arguments:
#   line            atom line to parse
#   atomVar         name of the variable to hold the atom
#   flagAlignVar    name of the variable to hold the column index for flags
#   flagsVar        name of the variable to hold the flags
#   commentVar      name of the variable to hold the line's ending comment
#   comAlignVar     name of the variable to hold the column index for the comment
#
# Globals: NONE
#
# Variables: NONE
#
# Return:
#   boolean indicating success or failure of parse
#############################################################################
proc ParsePackageLine {line atomVar flagAlignVar flagsVar commentVar comAlignVar} {
    upvar 1 $atomVar atom $flagAlignVar flagAlign $flagsVar flags $commentVar comment $comAlignVar comAlign
    # Parse the package line, fill in the variables and return the result
    set success [regexp -- {^(([^#[:space:]]+)\s+)((?:[^#[:space:]]+\s*)*)(\#.*)?$} $line -> flagAlign atom flags comment]
    set flagAlign [string length $flagAlign]
    set flags [list {*}$flags]
    set comAlign [string first # $line]
    return $success
}

#############################################################################
# Pad a line with spaces up to a given target length.
# If the line is already longer than the target length, append a single space.
#
# Arguments:
#   lineVar     variable name to pad
#   length      length to pad up to
#
# Globals: NONE
#
# Variables: NONE
#
# Return: NONE
#############################################################################
proc PadLine {lineVar length} {
    upvar 1 $lineVar line
    # Get the size of the line
    set size [string length $line]
    # Pad the line with spaces
    set line "$line [string repeat " " [expr {$length-$size-1}]]"
}


#############################################################################
#############################################################################
#
# Body
#
#############################################################################
#############################################################################

# Detect the operating mode based on the script name
if {[SetupMode [string tolower [string range [scriptName] 1 end]]]} {
    # Invalid mode: warn the user
    puts stderr "Warning: cannot determine operating mode from script name, defaulting to 'use'"
}

# Process command line arguments
set args {}
getopt flag arg $argv {
    -m: - --mode: {
        # Select the given mode
        if {[SetupMode $arg]} {
            # Invalid mode: bail out
            die "invalid mode: $arg" 2
        }
    }
    -f: - --file: {
        # Define a custom path
        set path $arg
    }
    -v - --verbose {
        # Increase the verbosity level
        incr verbose
    }
    -h? - --help {
        # Print the help
        puts "  Usage: [scriptName] \[options\] <atom> <$flagdesc>

Add or remove package-specific ${flagdesc}s.

Options:
  -m | --mode <mode>    operating mode ('use', 'key' or 'lic')
  -f | --file <file>    use <file> instead of the default $path
  -v | --verbose        print the resulting ${flagdesc}s
  -h | --help           print the help
  -V | --version        print the script version

${flagdesc}s can take the following form:
  +$mode | $mode            set the $flagdesc
  -$mode                  unset the $flagdesc
  %$mode                  reset the $flagdesc (remove it from the file)
  ?$mode                  query the $flagdesc
"
        # TODO: --pretend   don't do any changes ; with --verbose, print what would be done
        # TODO: --comment   add comment at end of line
        # TODO: --sort      just sort the file
        # TODO: multiple --verbose switches increase the level of verbosity
        exit 0
    }
    -V - --version {
        # Report the version of the program
        puts "[scriptName] version $version"
        exit 0
    }
    missing {
        die "option requires argument: $arg" 2
    }
    unknown {
        die "unknown or ambiguous option: $arg" 2
    }
    arglist {
        set args $arg
    }
}
# Get the atom and flags
set flagspecs [lassign $args atom]
# No atom and/or flag specified, bail out
if {$atom eq "" || ![llength $flagspecs]} {
    die "missing atom and/or ${flagdesc}s" 2
}
# Invalid atom, bail out
if {![regexp -- "^${constraint_rx}?(${category_rx})/${package_rx}(?:-${version_rx})?\$" $atom -> category]} {
    die "atom seems invalid: $atom" 2
}
set category [lindex [split $category -] 0]

# Read in the file
if {[catch {open $path r} fd]} {
    die "unable to read file $path" 1
}
set file [split [read -nonewline $fd] "\n"]
close $fd

# Search for the atom
set iline [lsearch -all -regexp $file "^[reEscape $atom]\\s"]
# Sanity check: only 1 atom in the file
if {[llength $iline] > 1} {
    die "more than 1 line match this atom" 1
} elseif {$iline eq ""} {
    # Else if atom no found: add it
    # Find and sort the atom's category block
    set catblock [lsort -dictionary [lsearch -all -inline -regexp $file "^${constraint_rx}?[reEscape $category]-"]]
    if {$catblock ne ""} {
        # Find the line that would be preceding the atom inside the block
        set neighbor [lsearch -bisect -inline $catblock $atom]
        if {$neighbor ne ""} {
            # Get the index for the next line in the file
            set insert [expr [lsearch -exact $file $neighbor]+1]
        } else {
            # Doesn't exist: atom would be the first of the block, take the current first line
            set neighbor [lindex $catblock 0]
            # Get the index for this line in the file
            set insert [lsearch -exact $file $neighbor]
        }
        # Extract the alignment of this block using the neighbor line
        if {![ParsePackageLine $neighbor - flagAlign - - comAlign]} {
            die "unable to determine category alignment" 1
        }
    } else {
        # No category block, must create one
        # Strip the file of comments and empty lines, then sort it
        set blocks [lsort -dictionary [lsearch -all -inline -not -regexp $file {^\s*(?:#.*)?$}]]
        # Find the last line of the preceding category block
        set neighbor [lsearch -bisect -inline $blocks $category]
        if {$neighbor ne ""} {
            # Get the index for this line in the file
            set insert [lsearch -exact $file $neighbor]
            # Find the ending empty line for the block
            while {![string is space $neighbor]} {
                incr insert
                set neighbor [lindex $file $insert]
            }
        } else {
            # Doesn't exist: block would be the first of the file, take the first line of the current first block
            set neighbor [lindex $blocks 0]
            # Get the index for this line in the file
            set insert [lsearch -exact $file $neighbor]
            # Find the opening empty line for the block
            while {![string is space $neighbor]} {
                incr insert -1
                set neighbor [lindex $file $insert]
            }
        }

        # Compute flags alignment as a multiple of 4
        set flagAlign [string length $atom]
        set flagAlign [expr {$flagAlign+4-($flagAlign%4)}]
        # Insert an empty line before creating the block
        set file [linsert $file $insert ""]
        incr insert
    }

    # Build the new line
    set flags [UpdateFlags {} $flagspecs]
    set nline $atom
    PadLine nline $flagAlign
    set nline "$nline[join $flags]"

    # Insert it in the file
    set file [linsert $file $insert $nline]
} else {
    # Else if atom found: update it
    # Get the current line
    set line [lindex $file $iline]
    # Parse the line
    if {![ParsePackageLine $line - flagAlign flags comment comAlign]} {
        die "unable to parse current ${flagdesc}s for this atom" 1
    }

    # Update the flags
    set flags [UpdateFlags $flags $flagspecs]
    # Check whether any flags remain
    if {[llength $flags]} {
        # Rebuild the line
        set nline $atom
        PadLine nline $flagAlign
        set nline "$nline[join $flags]"

        # Process the comment
        if {$comment ne ""} {
            # Pad the line
            PadLine nline $comAlign
            # Append the comment
            set nline "$nline$comment"
        }

        # Put the new line back in the file
        lset file $iline $nline
    } else {
        # Empty flags, remove the line
        lremove file $iline
    }
}

# Write back the file unless we did nothing else but query flags
if {!$queryonly} {
    if {[catch {open $path w} fd]} {
        die "unable to write to file $path" 1
    }
    puts $fd [join $file \n]
    close $fd
}

# Display the query results
if {$query ne ""} {
    set query [lsort -command CompareFlags $query]
    puts "Query: $atom [join $query]"
}
# If we're being verbose, display the resulting flags
if {$verbose} {
    puts "${flagdesc}s: $flags"
}

