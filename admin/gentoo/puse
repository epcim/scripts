#!/usr/bin/env tclsh8.6
#############################################################################
#   puse/pkey/plic                                                          #
#                                                                           #
# Script for management of Gentoo Portage flag files.                       #
# Respectful of file layout (category blocks, comments, blanks, ...).       #
# Handles:                                                                  #
#   * USE flags in package.use when called as 'puse'                        #
#   * keywords in package.accept_keywords when called as 'pkey'             #
#   * licenses in package.license when called as 'plic'                     #
#                                                                           #
# Atoms are parsed as per PMS EAPI 5, as DEPEND atoms.                      #
#                                                                           #
# History:                                                                  #
#   v0.2    Diversification: handle keywords and licenses                   #
#   v0.1    Initial version: handle USE flags only                          #
#############################################################################


#############################################################################
#############################################################################
#
# Packages
#
#############################################################################
#############################################################################

package require Tcl 8.6

lappend auto_path [file normalize [file join [file dirname $::argv0] ../../tcl]]

package require debug
package require getopt


#############################################################################
#############################################################################
#
# Globals
#
#############################################################################
#############################################################################

# Version number
set version "0.2"

# Operating mode (set by [SetupMode])
set mode ""

# Flag description (used in messages ; set by [SetupMode])
set flagdesc ""
# Flagspec status regexp
set flagstatusrx {[?%+-]}
# Flagspec regexp capturing status (+-?%) and flag (set by [SetupMode])
set flagrx ""

# Path to file (set by [SetupMode])
set path ""

# Verbosity level
set verbose 0

# Resulting flags
set flags ""
# Flag query results
set query ""
# Boolean holding whether only queries were done (no set/unset/reset)
set queryonly 1

# DEPEND atom regexps (see PMS EAPI 5 and ebuild(5) for specification)
set constraint_rx   {(?:<|<=|=|>=|>|~)}
set category_rx     {(?:[a-zA-Z0-9_][a-zA-Z0-9_+.-]*)}
set package_rx      {(?:[a-zA-Z0-9_][a-zA-Z0-9_+]*(?:-(?:[a-zA-Z0-9_+]*-)*[a-zA-Z_+]*)?)}
set version_rx      {(?:[0-9]+(?:\.[0-9]+)*[a-z]?(?:_(?:alpha|beta|pre|rc|p)[0-9]*)?)}
set revision_rx     {(?:r[0-9]+)}
set postfix_rx      {(?:\*)}
set use_rx          {(?:[a-zA-Z0-9][a-zA-Z0-9@_+-]*)}
set keyword_rx      {(?:~?[a-zA-Z0-9_][a-zA-Z0-9_-]*)}
set license_rx      {(?:[[:graph:]]+)}

#############################################################################
#############################################################################
#
# Procedures
#
#############################################################################
#############################################################################

#############################################################################
# Get the script name.
#
# Arguments: NONE
#
# Globals: NONE
#
# Variables: NONE
#
# Return:
#   script basename (no leading path, no trailing .tcl)
#############################################################################
proc scriptName {} {
    # Strip the path
    set base [file tail $::argv0]
    # Strip any trailing .tcl extension
    if {[file extension $base] eq ".tcl"} {
        set base [file rootname $base]
    }
    # Return the resulting basename
    return $base
}

#############################################################################
# Print an error message and bail out.
#
# Arguments:
#   message     error message
#   code        return code (default: 1)
#   prefix      optional prefix to the error message (default: "Error: ")
#
# Globals: NONE
#
# Variables: NONE
#
# Return: NONE
#############################################################################
proc die {message {code 1} {prefix "Error: "}} {
    # Print the message
    puts stderr ${prefix}${message}
    # Exit with the given return code
    exit $code
}

#############################################################################
# Escape a string for use in a regexp pattern.
#
# Arguments:
#   str     string to escape
#
# Globals: NONE
#
# Variables: NONE
#
# Return:
#   escaped string that can safely be used as a fixed string in a regexp
#############################################################################
proc reEscape {str} {
    regsub -all {\W} $str {\\&}
}

#############################################################################
# Remove indices from a list.
#
# Arguments:
#   listVar     list variable to strip indices from
#   indices     indices to strip from the list
#
# Globals: NONE
#
# Variables: NONE
#
# Return: NONE
#############################################################################
proc lremove {listVar indices} {
    upvar 1 $listVar list
    # Sort the indices in decreasing order (so that indices get removed from
    # the end of the list first and don't impact removal of other indices)
    set indices [lsort -integer -decreasing $indices]
    # Remove each index
    foreach i $indices {
        set list [lreplace $list $i $i]
    }
}

#############################################################################
# Setup the script variables according to the given operating mode.
# If the mode name is not valid, the default 'use' mode will be selected.
#
# Arguments:
#   m           user operating mode (possibly invalid)
#
# Globals:
#   mode            selected operating mode
#   flagdesc        flag description
#   flagstatusrx    flag status regexp
#   flagrx          flagspec regexp
#   path            path to the default target file of the mode
#   use_rx          USE flag regexp
#   keyword_rx      keyword regexp
#   license_rx      license regexp
#
# Variables: NONE
#
# Return:
#   boolean indicating whether the given mode name was valid
#############################################################################
proc SetupMode {m} {
    global mode
    global flagdesc
    global flagstatusrx
    global flagrx
    global path
    global use_rx
    global keyword_rx
    global license_rx

    # Switch according to the given mode, defaulting to "use" mode
    switch $m {
        "key" {
            # Remember the operating mode
            set mode "key"
            # Setup variables
            set path "/etc/portage/package.accept_keywords"
            set flagdesc "keyword"
            set flagrx "^(${flagstatusrx}?)(${keyword_rx})\$"
        }

        "lic" {
            # Remember the operating mode
            set mode "lic"
            # Setup variables
            set path "/etc/portage/package.license"
            set flagdesc "license"
            set flagrx "^(${flagstatusrx}?)(${license_rx})\$"
        }

        "use" -
        default {
            # Remember the operating mode
            set mode "use"
            # Setup variables
            set path "/etc/portage/package.use"
            set flagdesc "USE flag"
            set flagrx "^(${flagstatusrx}?)(${use_rx})\$"
        }
    }

    # Return whether the given mode name was valid
    return [expr {$mode ne $m}]
}

#############################################################################
# Break down an atom and return some parts of it.
#
# Available parts are:
#   constraint      return the atom's constraint
#   category        return the atom's category
#   name            return the atom's name
#   version         return the atom's version
#   revision        return the atom's revision
#   postfix         return the atom's postfix
#   basecat         return the atom's base category
#   subcat          return the atom's sub-category
#   basename        return the atom's base name (category + name)
#   package         return the atom's package name (base name + version)
#   fullver         return the atom's full version (version + revision)
#   fullpack        return the atom's full package name (package + revision)
#   *               special value that returns all parts 
#                   (same order as above; most useful with --dict)
#
# Available options:
#   -d|--dict       return the parts as a dict instead of a list
#
# Arguments:
#   options         options (see above; optional)
#   parts           a list of parts to return (see above)
#   atom            atom to break down
#
# Globals:
#   constraint_rx   constraint regexp
#   category_rx     category regexp
#   package_rx      package regexp
#   version_rx      version regexp
#   revision_rx     revision regexp
#   postfix_rx      postfix regexp
#
# Variables: NONE
#
# Return:
#   the specified atom parts
#############################################################################
proc Atom {args} {
    global constraint_rx
    global category_rx
    global package_rx
    global version_rx
    global revision_rx
    global postfix_rx

    # Define a function for appending to the return list
    proc _atom_part_append {var key value} {
        upvar $var list
        lappend list $value
    }

    # Parse the arguments
    set rargs {}
    getopt flag arg $args {
        -d - --dict {
            # Return a dict instead of a list: redefine the _atom_part_append function
            proc _atom_part_append {var key value} {
                upvar $var dict
                dict set dict $key $value
            }
        }
        missing {
            return -code error "option requires argument: $arg"
        }
        unknown {
            return -code error "unknown or ambiguous option: $arg"
        }
        arglist {
            set rargs $arg
        }
    }
    # Get the parts and atom
    lassign $rargs parts atom
    # No parts and/or atom specified, bail out
    if {![llength $parts] || $atom eq ""} {
        return -code error "missing parts and/or atom"
    }

    # Split the atom
    if {![regexp -- "^(${constraint_rx})?(((${category_rx})/(${package_rx}))(?:-((${version_rx})(?:-(${revision_rx}))?))?)(${postfix_rx})?\$" $atom -> constraint fullpack basename category name fullver version revision postfix]} {
        # Atom does not match regexp, bail out
        return -code error "invalid atom: $atom"
    }

    # Expand '*' in the list of parts into a list of all parts
    if {$parts eq "*"} {
        set parts {constraint category name version revision postfix basecat subcat basename package fullver fullpack}
    }

    # Build the return list/dict
    set ret {}
    foreach p $parts {
        switch $p {
            constraint -
            category -
            name -
            version -
            revision -
            postfix -
            basename -
            fullver -
            fullpack {
                # Directly use the value extracted from the regexp
                _atom_part_append ret $p [set $p]
            }

            basecat {
                # Split the category around - and return the 1st part
                _atom_part_append ret $p [lindex [split $category -] 0]
            }

            subcat {
                # Split the category around - and return the 2nd part
                _atom_part_append ret $p [lindex [split $category -] 1]
            }

            package {
                # Strip the revision field from the end of the full package name
                set offset 0
                if {$revision ne ""} {
                    # Remove as much chars as the length of the revision field + 1 for the preceding dash
                    set offset [expr {[string length $revision]+1}]
                }
                _atom_part_append ret $p [string range $fullpack 0 end-$offset]
            }

            default {
                # Unknown part, bail out
                return -code error "unknown part: $p"
            }
        }
    }

    # Return the list/dict
    return $ret
}


#############################################################################
# Parse a flagspec and return the status and flag name.
#
# Arguments:
#   flagspec    flagspec to parse
#   statusVar   status variable
#   flagVar     flag variable
#
# Globals:
#   flagrx      flagspec regexp
#
# Variables: NONE
#
# Return:
#   boolean indicating success or failure of parse
#############################################################################
proc ParseFlagspec {flagspec statusVar flagVar} {
    global flagrx
    upvar 1 $statusVar status $flagVar flag

    # Parse the flagspec according to the mode's regexp and return the result
    return [regexp -- $flagrx $flagspec -> status flag]
}

#############################################################################
# Compare two flagspecs alphabetically, ignoring leading symbols.
#
# Arguments:
#   fs1     first flagspec
#   fs2     second flagspec
#
# Globals: NONE
#
# Variables: NONE
#
# Return:
#   an integer less than, equal to, or greater than zero if the first
#   flagspec is to be considered less than, equal to, or greater than the
#   second, respectively
#############################################################################
proc CompareFlags {fs1 fs2} {
    # Get the flag names
    ParseFlagspec $fs1 - f1
    ParseFlagspec $fs2 - f2
    # Compare them
    return [string compare $f1 $f2]
}

#############################################################################
# Update a list of flags according to a list of flagspecs.
#
# Arguments:
#   flags       list of flags
#   flagspecs   list of flagspecs
#
# Globals:
#   query       holds the result of query flagspecs
#   queryonly   holds whether only queries were done on the flags
#
# Variables: NONE
#
# Return:
#   updated list of flags
#############################################################################
proc UpdateFlags {flags flagspecs} {
    global query queryonly

    # Process each flagspec
    foreach spec $flagspecs {
        # Parse the flagspec
        if {![ParseFlagspec $spec action flag]} {
            die "wrong format for flag: $spec" 2
        }
        if {$action eq ""} {
            set action "+"
        }
        # Search for the flag
        set iflag [lsearch -all -regexp $flags "^\[+-\]?[reEscape $flag]\$"]

        # Process the flag according to its action
        switch -- $action {
            + {
                # Set the flag
                # Remove all occurences of the flag
                lremove flags $iflag
                # Append the flagspec
                lappend flags $flag
                # By the way, now we're not just querying
                set queryonly 0
            }

            - {
                # Unset the flag
                # Remove all occurences of the flag
                lremove flags $iflag
                # Append the flagspec
                lappend flags -$flag
                # By the way, now we're not just querying
                set queryonly 0
            }

            % {
                # Reset the flag
                # Remove all occurences of the flag
                lremove flags $iflag
                # By the way, now we're not just querying
                set queryonly 0
            }

            ? {
                # Query the flag
                # Remove all occurences of the flag but the last
                lremove flags [lrange $iflag 0 end-1]
                # Append the state of the flag to the query results
                if {[llength $iflag] > 0} {
                    lappend query [lindex $flags [lindex $iflag end]]
                } else {
                    lappend query %$flag
                }
            }
        }
    }

    # Sort and return the flags
    return [lsort -command CompareFlags $flags]
}

#############################################################################
# Parse an atom line.
#
# NB: This does not check the validity of the atom.
#
# Arguments:
#   line            atom line to parse
#   atomVar         name of the variable to hold the atom
#   flagAlignVar    name of the variable to hold the column index for flags
#   flagsVar        name of the variable to hold the flags
#   commentVar      name of the variable to hold the line's ending comment
#   comAlignVar     name of the variable to hold the column index for the comment
#
# Globals: NONE
#
# Variables: NONE
#
# Return:
#   boolean indicating success or failure of parse
#############################################################################
proc ParsePackageLine {line atomVar flagAlignVar flagsVar commentVar comAlignVar} {
    upvar 1 $atomVar atom $flagAlignVar flagAlign $flagsVar flags $commentVar comment $comAlignVar comAlign
    # Parse the package line, fill in the variables and return the result
    set success [regexp -- {^(([^#[:space:]]+)\s+)((?:[^#[:space:]]+\s*)*)(\#.*)?$} $line -> flagAlign atom flags comment]
    set flagAlign [string length $flagAlign]
    set flags [lassign $flags]
    set comAlign [string first # $line]
    return $success
}

#############################################################################
# Pad a line up to a given target length.
# If the line is already longer than the target length, append a single character.
#
# Arguments:
#   lineVar     variable name to pad
#   length      length to pad up to
#   char        padding character (optional; defaults to a space)
#
# Globals: NONE
#
# Variables: NONE
#
# Return: NONE
#############################################################################
proc PadLine {lineVar length {char " "}} {
    upvar 1 $lineVar line
    # Get the size of the line
    set size [string length $line]
    # Pad the line with spaces
    set line "$line [string repeat $char [expr {$length-$size-1}]]"
}


#############################################################################
#############################################################################
#
# Body
#
#############################################################################
#############################################################################

# Detect the operating mode based on the script name
if {[SetupMode [string tolower [string range [scriptName] 1 end]]]} {
    # Invalid mode: warn the user
    puts stderr "Warning: cannot determine operating mode from script name, defaulting to 'use'"
}

# Process command line arguments
set args {}
getopt flag arg $argv {
    -m: - --mode: {
        # Select the given mode
        if {[SetupMode $arg]} {
            # Invalid mode: bail out
            die "invalid mode: $arg" 2
        }
    }
    -f: - --file: {
        # Define a custom path
        set path $arg
    }
    -v - --verbose {
        # Increase the verbosity level
        incr verbose
    }
    -h? - --help {
        # Print the help
        puts "  Usage: [scriptName] \[options\] <atom> <$flagdesc>

Add or remove package-specific ${flagdesc}s.

Options:
  -m | --mode <mode>    operating mode ('use', 'key' or 'lic')
  -f | --file <file>    use <file> instead of the default $path
  -v | --verbose        print the resulting ${flagdesc}s
  -h | --help           print the help
  -V | --version        print the script version

${flagdesc}s can take the following form:
  +$mode | $mode            set the $flagdesc
  -$mode                  unset the $flagdesc
  %$mode                  reset the $flagdesc (remove it from the file)
  ?$mode                  query the $flagdesc
"
        # TODO: --pretend   don't do any changes ; with --verbose, print what would be done
        # TODO: --comment   add comment at end of line
        # TODO: --sort      just sort the file
        # TODO: multiple --verbose switches increase the level of verbosity
        exit 0
    }
    -V - --version {
        # Report the version of the program
        puts "[scriptName] version $version"
        exit 0
    }
    missing {
        die "option requires argument: $arg" 2
    }
    unknown {
        die "unknown or ambiguous option: $arg" 2
    }
    arglist {
        set args $arg
    }
}
# Get the atom and flags
set flagspecs [lassign $args atom]
# No atom and/or flag specified, bail out
if {$atom eq "" || ![llength $flagspecs]} {
    die "missing atom and/or ${flagdesc}s" 2
}
# Check and parse the atom
if {[catch {set atomdict [Atom --dict * $atom]}]} {
    die "atom seems invalid: $atom" 2
}

# Read in the file
if {[catch {open $path r} fd]} {
    die "unable to read file $path" 1
}
set file [split [read -nonewline $fd] "\n"]
close $fd

# Search for the atom
set iline [lsearch -all -regexp $file "^[reEscape $atom]\\s"]
# Sanity check: only 1 atom in the file
if {[llength $iline] > 1} {
    die "more than 1 line match this atom" 1
} elseif {$iline eq ""} {
    # Else if atom not found: add it
    # Find the atom's category block
    set catblock [lsearch -all -inline -regexp $file "^${constraint_rx}?[reEscape [dict get $atomdict basecat]]\[/-\]?"]
    if {$catblock ne ""} {
        # Augment each line with its constraint-less atom, for sorting and searching
        set catblock [lmap l $catblock {
            list [join [Atom {fullpack postfix} [lindex $l 0]] {}] $l
        }]
        # Sort according to the constraint-less atom
        set catblock [lsort -dictionary -index 0 $catblock]
        # Find the line that would be preceding the atom inside the block
        set neighbor [lindex [lsearch -bisect -index 0 -inline $catblock [join [Atom {fullpack postfix} $atom] {}]] 1]
        if {$neighbor ne ""} {
            # Get the index for the next line in the file
            set insert [expr [lsearch -exact $file $neighbor]+1]
        } else {
            # Doesn't exist: atom would be the first of the block, take the current first line
            set neighbor [lindex $catblock 0 1]
            # Get the index for this line in the file
            set insert [lsearch -exact $file $neighbor]
        }
        # Extract the alignment of this block using the neighbor line
        if {![ParsePackageLine $neighbor - flagAlign - - comAlign]} {
            die "unable to determine category alignment" 1
        }
    } else {
        # No category block, must create one
        # Strip the file of comments and empty lines
        set blocks [lsearch -all -inline -not -regexp $file {^\s*(?:#.*)?$}]
        # Augment each line with its base category, for sorting and searching
        set blocks [lmap l $blocks {
            list [Atom basecat [lindex $l 0]] $l
        }]
        # Sort according to the base category
        set blocks [lsort -dictionary -index 0 $blocks]
        # Find the last line of the preceding category block
        set neighbor [lindex [lsearch -bisect -index 0 -inline $blocks [dict get $atomdict basecat]] 1]
        if {$neighbor ne ""} {
            # Get the index for this line in the file
            set insert [lsearch -exact $file $neighbor]
            # Find the ending empty line for the block
            while {![string is space $neighbor]} {
                incr insert
                set neighbor [lindex $file $insert]
            }
        } else {
            # Doesn't exist: block would be the first of the file, take the first line of the current first block
            set neighbor [lindex $blocks 0 1]
            # Get the index for this line in the file
            set insert [lsearch -exact $file $neighbor]
            # Find the opening empty line for the block
            while {![string is space $neighbor]} {
                incr insert -1
                set neighbor [lindex $file $insert]
            }
        }

        # Compute flags alignment as a multiple of 4
        set flagAlign [string length $atom]
        set flagAlign [expr {$flagAlign+4-($flagAlign%4)}]
        # Insert an empty line before creating the block
        set file [linsert $file $insert ""]
        incr insert
    }

    # Build the new line
    set flags [UpdateFlags {} $flagspecs]
    set nline $atom
    PadLine nline $flagAlign
    set nline "$nline[join $flags]"

    # Insert it in the file
    set file [linsert $file $insert $nline]
} else {
    # Else if atom found: update it
    # Get the current line
    set line [lindex $file $iline]
    # Parse the line
    if {![ParsePackageLine $line - flagAlign flags comment comAlign]} {
        die "unable to parse current ${flagdesc}s for this atom" 1
    }

    # Update the flags
    set flags [UpdateFlags $flags $flagspecs]
    # Check whether any flags remain
    if {[llength $flags]} {
        # Rebuild the line
        set nline $atom
        PadLine nline $flagAlign
        set nline "$nline[join $flags]"

        # Process the comment
        if {$comment ne ""} {
            # Pad the line
            PadLine nline $comAlign
            # Append the comment
            set nline "$nline$comment"
        }

        # Put the new line back in the file
        lset file $iline $nline
    } else {
        # Empty flags, remove the line
        lremove file $iline
    }
}

# Write back the file unless we did nothing else but query flags
if {!$queryonly} {
    if {[catch {open $path w} fd]} {
        die "unable to write to file $path" 1
    }
    puts $fd [join $file \n]
    close $fd
}

# Display the query results
if {$query ne ""} {
    set query [lsort -command CompareFlags $query]
    puts "Query: $atom [join $query]"
}
# If we're being verbose, display the resulting flags
if {$verbose} {
    puts "${flagdesc}s: $flags"
}

# vim:ft=tcl
