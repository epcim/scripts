#!/bin/bash
# Shutdown wrapper script that ensures you really want to shutdown
# Useful when there may be people logged in remotely and you don't have
# a login manager warning you that shutting down would be rude to them


# Build full name
[[ "${0:0:1}" == "/" ]] && full_0="$0" || full_0="$PWD/$0"

# Source required modules (bashmod first, then use it for the others)
[[ ! -r "${BASH_MODULES_SCRIPT=${full_0%/*}/../bash/modules/bashmod}" ]] && { echo "Error: This script requires the 'bashmod' module, please specify its path
       with the BASH_MODULES_SCRIPT environment variable." ; exit 255 ; }
source "$BASH_MODULES_SCRIPT"
bashmod die


help() {
    cat <<-EOF
	  Usage: ${0##*/} [options] [-- shutdown-options]
	
	'shutdown' wrapper that ensures you really want to shutdown.
	With no options, '-h now' is assumed.
	
	Options:
	  -e | --efi [ENTRY]        EFI entry to boot into on next bootup
	                            (requires efibootmgr)
	EOF
}

# Check for --help
if [[ "$1" =~ ^(-h|--help)$ ]]
then
    help
    exit
fi

# Process arguments
getopt -T &> /dev/null
(( $? != 4 )) && die "your getopt version is too old, get the enhanced getopt from util-linux!"
getopt="$(getopt -n "${0##*/}" -l efi:,help -o +e:h -- "$@")" || exit 128
eval set -- "$getopt"

# explicitly don't set efientry, we need to differentiate between unset and set to an empty value
while true
do
    case "$1" in
        -e|--efi) efientry="$2"; shift ;;
        -h|--help)
            help
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *) die "internal error!" ;;
    esac
    shift
done

# Print logged on users
echo -e "\033[01;33mLogged on users:\033[00m"
w || die "failed to list users"

# Shutdown if the user confirms
echo
echo -ne "\033[01;37mDo you really want to shutdown the computer? yes/no:\033[00m "
read -r ans
case "${ans,,}" in
    yes)
        # Set the entry to reboot on for EFI
        if [[ -v efientry ]]
        then
            # Check for efibootmgr
            PATH="$PATH:/sbin:/usr/sbin"
            command -v efibootmgr &>/dev/null || die "efibootmgr not found"

            # Set/reset the boot entry
            if [[ -n "$efientry" ]]
            then
                # Gather boot entries
                efientries="$(efibootmgr | sed -n -e 's/^Boot\([0-9A-Fa-f]\{4\}\)\*\? \(.*\)$/\1 \2/p')" || die "efibootmgr: failed to list boot entries"

                # Validate the boot entry
                efinum=
                while read -r bootnum bootname
                do
                    [[ "$efientry" == "$bootnum" || "$efientry" == "$bootname" ]] && { efinum="$bootnum"; break; }
                done <<<"$efientries"
                [[ -z "$efinum" ]] && die "invalid EFI boot entry: $efientry"

                # Set the BootNext entry
                sudo efibootmgr --bootnext "$efinum" || die "efibootmgr: failed to set next boot entry: $efinum"
            else
                # Reset the BootNext entry
                sudo efibootmgr --delete-bootnext || die "efibootmgr: failed to reset next boot entry"
            fi
        fi

        # Shutdown
        opts=(-h now)
        (( $# )) && opts=("$@")
        sudo shutdown "${opts[@]}"
        ;;

    no)
        # Easy peasy
        ;;

    *)
        echo "This doesn't make any sense."
        exit 1
        ;;
esac
