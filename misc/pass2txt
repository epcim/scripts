#!/bin/bash
# Convert a pass-managed password store into a single encrypted text file

if [[ "$1" == "-h" || "$1" == "--help" ]]
then
    cat <<- _EOF_
	  Usage: ${0##*/} [output file]
	
	Convert a pass-managed password store into a single encrypted text file.
	
	Password store location:     \$PASSWORD_STORE_DIR
	                             (default: \$HOME/.password-store)
	GPG options for input file:  --quiet --batch --decrypt
	GPG options for output file: --encrypt --armor
	_EOF_
    exit
fi

# Define constants
gpg=gpg2
pass_dir="${PASSWORD_STORE_DIR:-$HOME/.password-store}"

# Define functions
# decrypt_entry(file): decrypt a single file and print its contents
function decrypt_entry() {  # 1: file
    local c
    local t
    # Extract the entry name
    c="${1#$pass_dir/}"
    c="${c%.gpg}"
    # Decrypt the entry
    t="$("$gpg" --quiet --batch --decrypt "$f")" && echo "$c" >&2 || { echo "FAIL $c" >&2 ; return ; }
    # Print the entry
    printf "[%s]\n" "$c"
    sed -e '/^[[:space:]]*$/d' <<< "$t"
    printf "\n\n"
}

# Enable globstar to list all files under $pass_dir
shopt -s globstar

# Clear the output file
[[ -z "$1" ]] && rm -f "$1"

# Loop over all files, decrypt them and encrypt them back in a single text file (or stdout)
{
    for f in "$pass_dir"/**
    do
        [[ -d "$f" ]] && continue
        [[ "${f:(-4)}" != ".gpg" ]] && continue
        decrypt_entry "$f"
    done
} | "$gpg" --encrypt --armor > "${1:-/dev/stdout}"

