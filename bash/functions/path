#!/bin/bash
# path - manipulate path environment variables

function path() {
    # No argument: display help
    if [[ $# -lt 1 ]]
    then
        echo "  Usage: $FUNCNAME <action> [options] <variable> [DIRS]"
        echo "Manipulate path-like environment variables."
        echo
        echo "Any variable name ending in PATH may be altered."
        echo "Common path variables are aliased to short names (e.g. bin -> PATH,"
        echo "lib -> LD_LIBRARY_PATH) for ease of use. These aliases are listed"
        echo "below."
        echo "By default, the 'show' action only lists aliased variables. However"
        echo "each time a non-default variable is altered or shown, it is remembered"
        echo "and will be displayed upon the next 'show'."
        echo
        echo "Actions:"
        echo "  show            print the path (default action)"
        echo "  append          append DIRS to the path"
        echo "  prepend         prepend DIRS to the path"
        echo "  strip           strip DIRS from the path"
        echo
        echo "Generic options:"
        echo "  -e|--export     export the environment variable"
        echo "  -v|--verbose    print the resulting path"
        echo
        echo "Specific options for action 'show':"
        echo "  -r|--reset      forget non-default variables"
        echo
        echo "Specific options for action 'strip':"
        echo "  -g|--glob       also strip when only part of an entry is matched"
        echo
        echo "Path variables:"
        echo "  bin   -> PATH"
        echo "  lib   -> LD_LIBRARY_PATH"
        echo "  pkc   -> PKG_CONFIG_PATH"
        echo "  inc   -> C_INCLUDE_PATH"
        echo "           CPLUS_INCLUDE_PATH"
        echo "  man   -> MANPATH"
        echo "  *PATH -> itself"
        return
    fi
    local BLACK='\E[0m'           # Not real black: default setting, in fact
    local GREEN='\E[1;32;32m'     # Bold green color

    # Important note: since we're working with paths, the script must be kept pure-bash
    #                 wouldn't want to depend on something like 'sed' when
    #                 the user strips "/usr/bin" from its path

    # Enable extended globbing if needed
    local CLEAR_EXTGLOB=
    if ! shopt extglob &> /dev/null
    then
        CLEAR_EXTGLOB='true'
        shopt -s extglob
    fi

    # Get action from arguments
    local SELECTED_ACTION="$1"
    local ACTIONS=
    case "$SELECTED_ACTION" in
        "show"|"strip")
            ACTIONS="$SELECTED_ACTION"
            ;;

        "append"|"prepend")
            # Add 'strip' action before 'prepend' or 'append' to make sure DIRS are not in the path anymore
            ACTIONS="strip $SELECTED_ACTION"
            ;;

        *)
            echo "Error: unknown action '$SELECTED_ACTION'!" >&2
            return 1
            ;;
    esac
    shift

    # Parse options
    local EXPORT=
    local GLOB=
    local RESET=
    local VERBOSE=
    local OPTS_DONE=
    until [[ "$OPTS_DONE" ]]
    do
        # Extract option
        local OPTION='ERROR'
        case "$1" in
            # Long option
            --*)
                # Extract the option name
                OPTION="${1:2}"
                shift
                ;;

            # Short option
            -*)
                # Test for empty option
                if [[ "$1" == "-" ]]
                then
                    echo "Error: empty option flag '$1'!" >&2
                    return 1
                fi

                # Extract the option short name
                OPTION="${1:1:1}"
                # Test if any options are left
                if [[ -z "${1:2}" ]]
                then
                    # No more options here: shift
                    shift
                else
                    # Reset the positional parameters without the current option
                    set - "-${1:2}" "${@:2}"
                    # Don't shift yet
                fi
                ;;

            # Not an option
            *)
                OPTION=
                ;;
        esac

        # Process option
        case "$OPTION" in
            "e"|"export")
                EXPORT='true'
                ;;

            "g"|"glob")
                GLOB='true'
                [[ "$ACTIONS" != "strip" ]] && { echo "Error: invalid option '$OPTION' for action '$SELECTED_ACTION'!" >&2 ; return 1 ; }
                ;;

            "r"|"reset")
                RESET='true'
                [[ "$ACTIONS" != "show" ]] && { echo "Error: invalid option '$OPTION' for action '$SELECTED_ACTION'!" >&2 ; return 1 ; }
                ;;

            "v"|"verbose")
                VERBOSE='true'
                ;;

            "")
                OPTS_DONE='true'
                ;;

            *)
                echo "Error: unkown option '$OPTION'!" >&2
                return 1
        esac
    done

    # Get target path variable
    local TARGETS=
    if [[ "$ACTIONS" == "show" && -z "$1" ]]
    then
        # Show action with no path specified: show all path variables (including custom ones, except if reset)
        [[ "$RESET" ]] && unset PATH_CUSTOM_VARIABLES
        TARGETS="PATH LD_LIBRARY_PATH PKG_CONFIG_PATH C_INCLUDE_PATH CPLUS_INCLUDE_PATH MANPATH ${PATH_CUSTOM_VARIABLES[@]}"
    else
        case "$1" in
            bin)
                TARGETS=PATH
                ;;

            lib)
                TARGETS=LD_LIBRARY_PATH
                ;;

            pkc)
                TARGETS=PKG_CONFIG_PATH
                ;;

            inc)
                TARGETS="C_INCLUDE_PATH CPLUS_INCLUDE_PATH"
                ;;

            man)
                TARGETS=MANPATH
                ;;

            *([[:word:]])PATH)
                TARGETS=$1

                # Look for this path variable in the list of custom path variables
                local FOUND=
                local K
                for K in "${!PATH_CUSTOM_VARIABLES[@]}"
                do
                    # Found it
                    [[ "${PATH_CUSTOM_VARIABLES[$K]}" == "$TARGETS" ]] && { FOUND="$K" ; break ; }
                done
                # Check whether the path variable was found
                if [[ "$FOUND" ]]
                then
                    # Forget this path if the --reset option has been given
                    [[ "$RESET" ]] && unset PATH_CUSTOM_VARIABLES[$FOUND]
                else
                    # Remember the variable for later display with 'show' (this is NOT a local variable!)
                    PATH_CUSTOM_VARIABLES+=("$TARGETS")
                fi
                ;;

            *)
                echo "Error: invalid path variable '$1'!" >&2
                return 1
                ;;
        esac
    fi
    shift

    # Process actions
    local A
    for A in $ACTIONS
    do
        case "$A" in
            # Show: force verbose
            "show")
                VERBOSE='true'
                ;;

            # Append|Prepend: add DIRS to the specified path variable
            "append"|"prepend")
                # Build new path directories list
                [[ -z "$1" ]] && { echo "Error: empty directory path in DIRS!" >&2 ; return 1 ; }
                local NEWPATH="$1"
                shift
                local D
                for D in "$@"
                do
                    [[ -z "$D" ]] && { echo "Error: empty directory path in DIRS!" >&2 ; return 1 ; }
                    NEWPATH="$NEWPATH:$D"
                done

                # Add new path directories list
                local T
                for T in $TARGETS
                do
                    [[ -z "${!T}" ]] && eval $T="$NEWPATH" || { [[ "$A" == "append" ]] && eval $T="${!T}:$NEWPATH" || eval $T="$NEWPATH:${!T}" ; }
                done
                ;;

            # Strip: remove DIRS from the specified path variable
            "strip")
                local T
                for T in $TARGETS
                do
                    # Trick: wrap the path in ':' and replace inner ':' with '::'
                    local TEMPPATH=":${!T//:/::}:"

                    # Strip directories
                    local D
                    for D in "$@"
                    do
                        # String remove ':DIR:' (that's why we need the enclosing ':' above ;
                        # the '::' are needed so that consecutive matching entries are also caught)
                        local PATTERN=":$D:"
                        [[ "$GLOB" ]] && PATTERN=":*([!:])$D*([!:]):"
                        TEMPPATH="${TEMPPATH//$PATTERN/}"
                    done

                    # Reverse trick: unwrap the path, replace inner '::' with ':'
                    TEMPPATH="${TEMPPATH//::/:}"
                    TEMPPATH="${TEMPPATH#:}"
                    TEMPPATH="${TEMPPATH%:}"

                    # Assign the new path
                    eval $T="$TEMPPATH"
                done
                ;;
        esac
    done

    # Export the variables
    if [[ "$EXPORT" ]]
    then
        local T
        for T in $TARGETS
        do
            export $T
        done
    fi

    # Be verbose
    if [[ "$VERBOSE" ]]
    then
        local T
        for T in $TARGETS
        do
            echo -e "${GREEN}$T =${BLACK} ${!T}"
        done
    fi

    # Disable extended globbing if needed
    if [[ "$CLEAR_EXTGLOB" ]]
    then
        shopt -u extglob
    fi
}

