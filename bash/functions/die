#!/bin/bash
# die - print a message and exit on error, preserving original error code

function die() {
    # Get the last return code
    local RC=$?
    local PREFIX="Error: "
    local MSG
    # Parse arguments
    while [[ $# -gt 0 ]]
    do
        case "$1" in
            -h|--help)
                # Special case: print help and return (no exit)
                echo "  Usage: $FUNCNAME [options] [error message]

Options:
  -i|--inline               only print the error message (no prefix)
  -p|--prefix <prefix>      set the prefix preceding the error message
                            default: \"Error: \"
  -r|--return <code>        set the return code
                            default: \$?"
                return
                ;;

            -i|--inline)
                PREFIX=""
                ;;

            -p*|--prefix)
                PREFIX=""
                [[ "${1:0:2}" == "-p" ]] && PREFIX=${1#-p}
                [[ -z "$PREFIX" ]] && { PREFIX="$2" ; shift ; }
                ;;

            -r*|--return)
                RC=""
                [[ "${1:0:2}" == "-r" ]] && RC=${1#-r}
                [[ -z "$RC" ]] && { RC="$2" ; shift ; }
                ;;

            --)
                shift
                break
                ;;

            *)
                # Don't die on unknown arg, we're already dying
                break
                ;;
        esac
        shift
    done
    # Get the message
    while [[ $# -gt 0 ]]
    do
        MSG="${MSG:+$MSG }$1"
        shift
    done
    # Handle empty message a bit differently
    [[ -z "$MSG" ]] && { PREFIX="" ; MSG="Error!" ; }
    # Print message
    echo -e "$PREFIX$MSG" 1>&2
    # Exit with return code (return if interactive)
    [[ $- == *i* ]] && return $RC || exit $RC
}

