#!/bin/bash


# Build full name
[[ "${0:0:1}" == "/" ]] && full_0="$0" || full_0="$PWD/$0"

# Source required modules (bashmod first, then use it for the others)
[[ ! -r "${BASH_MODULES_SCRIPT=${full_0%/*}/../bash/functions/bashmod}" ]] && { echo "Error: This script requires the 'bashmod' module, please specify its path
       with the BASH_MODULES_SCRIPT environment variable." ; exit 255 ; }
source "$BASH_MODULES_SCRIPT"
bashmod die


# Environment variables
: "${KERNELDIR:=/usr/src/linux}"
: "${KERNELCONF:=$KERNELDIR/.config.cobalt}"
: "${GRUBCFG:=/boot/grub/grub.cfg}"


# Display help
if [[ "$1" == "-h" || "$1" == "--help" ]] ; then
    cat <<- _EOF_
	  Usage: ${0##*/} [options]
	
	Builds a kernel and its initramfs with LVM, framebuffer and splash
	support, but without modules and HW detection logic.
	Can also add \`v86d\` to the initramfs, update Grub, and emerge
	@module-rebuild.
	
	The kernel is configured and built in \$KERNELDIR (default "/usr/src/linux"):
	    $KERNELDIR
	using configuration \$KERNELCONF (default "\$KERNELDIR/.config.cobalt"):
	    $KERNELCONF
	The Grub configuration file is \$GRUBCFG (default "/boot/grub/grub.cfg"):
	    $GRUBCFG
	
	Options:
	    -n                      negate a following short option
	    -g | --[no-]grub        update Grub
                                (default: enabled)
	    -k | --[no-]kernel      build the kernel itself
                                (default: enabled)
	    -m | --[no-]modules     emerge @module-rebuild
                                (default: enabled)
	    -u | --[no-]uvesafb     perform additional steps (add v86d
	                            to initramfs) for uvesafb
                                (default: disabled)
	_EOF_
    exit
fi

# Process options
getopt -T &> /dev/null
(( $? != 4 )) && die -r128 "your getopt version is too old, get the enhanced getopt from util-linux!"
getopt="$(getopt -n "${0##*/}" -l grub,no-grub,kernel,no-kernel,modules,no-modules,uvesafb,no-uvesafb -o +ngkmu -- "$@")"
(( $? != 0 )) && exit 1
eval set -- "$getopt"
true=true       # trick for -n
negate=false
grub=true
kernel=true
modules=true
uvesafb=false
while true ; do
    # Negate if previous option was -n, and reset negation
    $negate && true=false
    negate=false
    case "$1" in
        -n) negate=true ;;
        -g) grub=$true ;;
        --grub) grub=true ;;
        --no-grub) grub=false ;;
        -k) kernel=$true ;;
        --kernel) kernel=true ;;
        --no-kernel) kernel=false ;;
        -m) modules=$true ;;
        --modules) modules=true ;;
        --no-modules) modules=false ;;
        -u) uvesafb=$true ;;
        --uvesafb) uvesafb=true ;;
        --no-uvesafb) uvesafb=false ;;
        --) shift ; break ;;
        *) die "getopt failure" ;;
    esac
    # Reset trueness
    true=true
    shift
done
(( $# > 0 )) && die "unhandled arguments: $@"


# Build directory
builddir="$KERNELDIR/build"



if $kernel ; then
    (
        # Ok, let's get paranoid about permissions now. The kernel build below will generate the kernel's signing key for modules, and we don't want these to be world-readable.
        umask 0027

        # Create the build directory as genkernel fails without it
        mkdir -p "$builddir"

        # Build the kernel:
        # * save the config in /etc/kernels (--save-config)
        # * assume the config is fine (--no-oldconfig)
        # * clean up, but not too much (--no-mrproper --no-clean)
        # * install on /boot and symlink it (--mountboot --install --symlink)
        # * kernel directory and configuration from the environment (--kerneldir --kernel-config)
        # * separate kernel build directory (--kernel-outputdir)
        # * custom kernel name (--kernname)
        # * build fast (--makeopts)
        # * don't ask for the keymap on boot, it's already on the Grub command line (--no-keymap)
        # * fancyness (--splash --splash-res)
        # * don't include modules and firmware in the initramfs, it's a custom kernel with all required components built in (--no-ramdisk-modules --no-all-ramdisk-modules)
        # * initramfs components (--lvm --no-mdadm --no-dmraid --no-luks)
        # * include v86d if requested (--initramfs-overlay) -- UNUSED, UNTESTED
        # * use the best compression available in the kernel configuration (--compress-initramfs-type="best")
        genkernel --save-config --no-oldconfig --no-mrproper --clean --mountboot --install --symlink --kerneldir="$KERNELDIR" --kernel-config="$KERNELCONF" --kernel-outputdir="$builddir" --kernname="cobalt" --makeopts="-j8" --no-keymap --splash="emerge-world" --splash-res="1920x1080" --no-ramdisk-modules --no-all-ramdisk-modules --no-firmware --lvm --no-mdadm --no-dmraid --no-luks ${uvesafb:+--initramfs-overlay=/usr/share/v86d/initramfs} --compress-initramfs-type="best" all
        rc=$?

        # Fine, now let's loosen the restrictions a bit so that portage can still build external modules
        echo
        echo "chgrp -R portage $KERNELDIR/"
        chgrp -R portage "$KERNELDIR/"      # trailing / is important to chmod the actual directory
                                            # and not the symlink (in the KERNELDIR=/usr/src/linux case)

        # Exit the subshell with genkernel's return code
        exit "$rc"
    ) || exit 1
fi


# Configure Grub
if $grub ; then
    echo
    echo
    if [[ -f "$GRUBCFG" ]]
    then
        grub2-mkconfig -o "$GRUBCFG"
    else
        echo "Warning: cannot update Grub: '$GRUBCFG' not found" >&2
    fi
fi


# Emerge external modules
if $modules ; then
    echo
    echo
    # The linux-mod/linux-info eclasses need KERNEL_DIR/KBUILD_OUTPUT to use the right kernel
    KERNEL_DIR="$KERNELDIR" KBUILD_OUTPUT="$builddir" emerge --quiet-build y --keep-going @module-rebuild

    # Sign the modules
    echo
    echo
    echo "Signing modules:"
    kernelversion="$(cat "$builddir/include/config/kernel.release")"
    sigtext="~Module signature appended~"
    for module in $(equery f $(equery b "/lib/modules/$kernelversion") | grep '^/lib/modules/'"$kernelversion"'/.*\.ko$')
    do
        echo -n "$module "
        if [[ "$(dd if="$module" iflag=skip_bytes skip="$(($(stat -c %s "$module") - ${#sigtext} - 1))" status=none)" == "$sigtext" ]] ; then
            echo "ALREADY SIGNED"
        else
            "$builddir/scripts/sign-file" sha512 "$builddir/certs/signing_key.pem" "$builddir/certs/signing_key.x509" "$module" && echo OK || echo FAIL
        fi
    done
fi
