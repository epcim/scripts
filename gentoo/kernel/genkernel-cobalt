#!/bin/bash


# Build full name
[[ "${0:0:1}" == "/" ]] && full_0="$0" || full_0="$PWD/$0"

# Source required modules (bashmod first, then use it for the others)
[[ ! -r "${BASH_MODULES_SCRIPT=${full_0%/*}/../bash/functions/bashmod}" ]] && { printf "Error: This script requires the 'bashmod' module, please specify its path\n       with the BASH_MODULES_SCRIPT environment variable.\n" ; exit 255 ; }
source "$BASH_MODULES_SCRIPT"
bashmod die


# Environment variables
: "${KERNELDIR:=/usr/src/linux}"
: "${KERNELCONF:=$KERNELDIR/.config.cobalt}"
: "${GRUBCFG:=/boot/grub/grub.cfg}"


# Functions
function verbosedo() {
    err="$1"
    shift
    echo "  $*"
    "$@" || die "$err"
}


# Display help
if [[ "$1" =~ ^(-h|--help)$ ]]
then
    cat <<- EOF
	  Usage: ${0##*/} [options]
	
	Builds a kernel and its initramfs with LVM, framebuffer and splash
	support, but without modules and HW detection logic.
	Can also add \`v86d\` to the initramfs, update Grub, and emerge
	@module-rebuild.
	
	The kernel is configured and built in \$KERNELDIR (default "/usr/src/linux"):
	    $KERNELDIR
	using configuration \$KERNELCONF (default "\$KERNELDIR/.config.cobalt"):
	    $KERNELCONF
	The Grub configuration file is \$GRUBCFG (default "/boot/grub/grub.cfg"):
	    $GRUBCFG
	
	Options:
	    -n                      negate a following short option
	    -g | --[no-]grub        update Grub
	                            (default: enabled)
	    -k | --[no-]kernel      build the kernel itself
	                            (default: enabled)
	    -m | --[no-]modules     emerge @module-rebuild
	                            (default: enabled)
	    -u | --[no-]uvesafb     perform additional steps (add v86d
	                            to initramfs) for uvesafb
	                            (default: disabled)
	EOF
    exit
fi

# Process options
getopt -T &> /dev/null
(( $? != 4 )) && die -r128 "your getopt version is too old, get the enhanced getopt from util-linux!"
getopt="$(getopt -n "${0##*/}" -l grub,no-grub,kernel,no-kernel,modules,no-modules,uvesafb,no-uvesafb -o +ngkmu -- "$@")"
(( $? != 0 )) && exit 1
eval set -- "$getopt"
true=true       # trick for -n
negate=false
grub=true
kernel=true
modules=true
uvesafb=        # empty value: used with ${uvesafb:+whatever}
while true
do
    # Negate if previous option was -n, and reset negation
    $negate && true=false
    negate=false
    case "$1" in
        -n) negate=true ;;
        -g) grub=$true ;;
        --grub) grub=true ;;
        --no-grub) grub=false ;;
        -k) kernel=$true ;;
        --kernel) kernel=true ;;
        --no-kernel) kernel=false ;;
        -m) modules=$true ;;
        --modules) modules=true ;;
        --no-modules) modules=false ;;
        -u) uvesafb=$true ;;
        --uvesafb) uvesafb=yes ;;
        --no-uvesafb) uvesafb= ;;   # empty value: used with ${uvesafb:+whatever}
        --) shift ; break ;;
        *) die "getopt failure" ;;
    esac
    # Reset trueness
    true=true
    shift
done
(( $# > 0 )) && die "unhandled arguments: $@"


# Build directory
builddir="$KERNELDIR/build"



## Build the kernel
if $kernel
then
    # Ok, let's get paranoid about permissions now. The kernel build below will generate the kernel's signing key for modules, and we don't want these to be world-readable -- or even portage-readable.
    umask="$(umask)"
    echo
    echo "kernel lockdown:"
    verbosedo "kernel lockdown failed" umask 0027
    verbosedo "kernel lockdown failed" chmod 700 "$KERNELDIR/"      # trailing / is important to chgrp the actual directory and not the symlink (in the KERNELDIR=/usr/src/linux case)
    echo

    # Create the build directory as genkernel fails without it
    mkdir -p "$builddir" || die "build directory creation failed"

    # Build the kernel:
    # * save the config in /etc/kernels (--save-config)
    # * assume the config is fine (--no-oldconfig)
    # * clean up, but not too much (--no-mrproper --no-clean)
    # * install on /boot and symlink it (--mountboot --install --symlink)
    # * kernel directory and configuration from the environment (--kerneldir --kernel-config)
    # * separate kernel build directory (--kernel-outputdir)
    # * custom kernel name (--kernname)
    # * build fast (--makeopts)
    # * don't ask for the keymap on boot, it's already on the Grub command line (--no-keymap)
    # * fancyness (--splash --splash-res)
    # * don't include modules and firmware in the initramfs, it's a custom kernel with all required components built in (--no-ramdisk-modules --no-all-ramdisk-modules)
    # * initramfs components (--lvm --no-mdadm --no-dmraid --no-luks)
    # * include v86d if requested (--initramfs-overlay) -- UNUSED, UNTESTED
    # * use the best compression available in the kernel configuration (--compress-initramfs-type="best")
    genkernel --save-config --no-oldconfig --no-mrproper --clean --mountboot --install --symlink --kerneldir="$KERNELDIR" --kernel-config="$KERNELCONF" --kernel-outputdir="$builddir" --kernname="cobalt" --makeopts="-j8" --no-keymap --splash="emerge-world" --splash-res="1920x1080" --no-ramdisk-modules --no-all-ramdisk-modules --no-firmware --lvm --no-mdadm --no-dmraid --no-luks ${uvesafb:+--initramfs-overlay=/usr/share/v86d/initramfs} --compress-initramfs-type="best" all || die "kernel build failed"

    # Fine, now let's loosen the restrictions a bit so that portage can still build external modules -- but keep the keys locked
    echo
    echo "kernel partial unlock:"
    verbosedo "kernel unlock failed" chgrp -R portage "$KERNELDIR/"                 # trailing / is important to chgrp the actual directory and not the symlink (in the KERNELDIR=/usr/src/linux case)
    verbosedo "kernel unlock failed" chgrp root "$builddir"/certs/signing_key.*
    verbosedo "kernel unlock failed" chmod 600 "$builddir"/certs/signing_key.*
    verbosedo "kernel unlock failed" chmod 750 "$KERNELDIR/"                        # trailing / is important to chgrp the actual directory and not the symlink (in the KERNELDIR=/usr/src/linux case)
    verbosedo "kernel unlock failed" umask "$umask"
fi


## Configure Grub
if $grub
then
    echo
    echo
    if [[ -f "$GRUBCFG" ]]
    then
        grub2-mkconfig -o "$GRUBCFG" || die "GRUB configuration failed"
    else
        echo "Warning: cannot update Grub: '$GRUBCFG' not found" >&2
    fi
fi


## Build external modules
if $modules
then
    # Emerge external modules
    echo
    echo
    # Find out whether we're building a PaX kernel and adjust USE flags accordingly
    grep -q '^CONFIG_PAX=y$' "$KERNELCONF" && export USE=pax_kernel || export USE=-pax_kernel
    # The linux-mod/linux-info eclasses need KERNEL_DIR/KBUILD_OUTPUT to use the right kernel and build directory
    KERNEL_DIR="$KERNELDIR" KBUILD_OUTPUT="$builddir" emerge --quiet-build y --keep-going @module-rebuild || die "emerge modules failed"

    # Sign the modules
    echo
    echo
    echo "Signing modules:"
    kernelversion="$(< "$builddir/include/config/kernel.release")"
    sigtext="~Module signature appended~"
    for module in $(equery f $(equery b "/lib/modules/$kernelversion") | grep '^/lib/modules/'"$kernelversion"'/.*\.ko$')
    do
        echo -n "$module "
        # Look for "~Module signature appended~" at the end of the file
        if [[ "$(dd if="$module" iflag=skip_bytes skip="$(($(stat -c %s "$module") - ${#sigtext} - 1))" status=none)" == "$sigtext" ]]
        then
            echo "ALREADY SIGNED"
        else
            "$builddir/scripts/sign-file" sha512 "$builddir/certs/signing_key.pem" "$builddir/certs/signing_key.x509" "$module" && echo OK || echo FAIL
        fi
    done
fi
