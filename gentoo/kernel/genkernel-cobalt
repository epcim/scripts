#!/bin/bash


# Build full name
[[ "${0:0:1}" == "/" ]] && full_0="$0" || full_0="$PWD/$0"


# Early functions
die() { # *:message
    printf "Error: %s\n" "$*"
    exit 1
} >&2


# Environment variables
: "${KERNELDIR:=/usr/src/linux}"
: "${KERNELENV:=$KERNELDIR/.gkenv}"
: "${KERNELCONF:=$KERNELDIR/.config.cobalt}"
: "${GRUBCFG:=/boot/grub/grub.cfg}"
: "${EFIPART:=/boot/efi}"
: "${EFIKERNEL:=/EFI/Boot/gentoo.efi}"
: "${EFIOLDKERNEL:=$EFIKERNEL.old}"
: "${EFILABEL:=Gentoo Linux}"
: "${EFIVARFS:=efivarfs}"
: "${PLYMOUTHDCONF:=/etc/plymouth/plymouthd.conf}"
EMERGEOPTS=( $EMERGEOPTS )

if [[ -f "$KERNELENV" ]]
then
    source "$KERNELENV" || die "failed to source configuration variables from $KERNELENV"
fi

# Global variables
efipart_mounted=false
splash_default_theme="$(sed -n -e 's/^Theme=\(.*\)$/\1/p' "$PLYMOUTHDCONF")"
: "${splash_default_theme:=spinner}"


# Functions
help() {
    cat <<-EOF
	  Usage: ${0##*/} [options]
	
	Builds a kernel and its integrated initramfs with LUKS, LVM, and the
	fr-bÃ©po keymap, but without modules and HW detection logic.
	Can also include boot splash with Plymouth, update Grub, sign (for Secure
	Boot) and install the kernel to an EFI System partition, and \`emerge
	@module-rebuild\` (and sign the modules).
	
	The kernel is configured and built in \$KERNELDIR (default "/usr/src/linux"):
	    ${KERNELDIR:-(empty)}
	using configuration \$KERNELCONF (default "\$KERNELDIR/.config.cobalt"):
	    ${KERNELCONF:-(empty)}
	EOF
    if [[ "$1" == "full" ]]
    then
        cat <<-EOF
		The EFI System partition is mounted at \$EFIPART (default "/boot/efi"):
		    ${EFIPART:-(empty)}
		The EFI kernel path is \$EFIKERNEL (default "/EFI/Boot/gentoo.efi"):
		    ${EFIKERNEL:-(empty)}
		The EFI old kernel path is \$EFIOLDKERNEL (default "\$EFIKERNEL.old"):
		    ${EFIOLDKERNEL:-(empty)}
		The EFI boot label is \$EFILABEL (default "Gentoo Linux"):
		    ${EFILABEL:-(empty)}
		The EFI variables filesystem is \$EFIVARFS (default "efivarfs"):
		    ${EFIVARFS:-efivarfs}
		The Grub configuration file is \$GRUBCFG (default "/boot/grub/grub.cfg"):
		    ${GRUBCFG:-(empty)}
		The Plymouth configuration file is \$PLYMOUTHDCONF (default "/etc/plymouth/plymouthd.conf"):
		    ${PLYMOUTHDCONF:-(empty)}
		The Plymouth default theme is (from \$PLYMOUTHDCONF, default: "spinner"):
		    $splash_default_theme
		Emerge is called with additional options from \$EMERGEOPTS (default empty):
		    ${EMERGEOPTS:-(empty)}
		EOF
    fi
	cat <<-EOF
	
	Configuration variables are sourced from \$KERNELDIR/.gkenv if it exists.
	
	Options:
	    -n                          negate a following short option
	    -e | --[no-]efi             update the EFI System partition
	                                (default: enabled)
	    -g | --[no-]grub            update Grub
	                                (default: disabled)
	    -k | --[no-]kernel          build the kernel itself
	                                (default: enabled)
	    -m | --[no-]modules         emerge @module-rebuild
	                                (default: enabled)
	    -s | --[no-]splash <theme>  include boot splash using Plymouth
	                                (default: disabled, theme: from configuration)
	    -h | --help [full]          display help
	EOF
    exit
}
require() {     # 1:command 2:reqby
    command -v "$1" &>/dev/null || die "$1 is required for $2 but not available"
}
verbosedo() {   # 1:error_message *:command
    err="$1"
    shift
    echo "  $*"
    "$@" || die "$err"
}
cleanup() {
    [[ "$efivarfs_access" == ro ]] && { mount -o remount,ro "$EFIVARFS" || echo "Error: failed to remount EFI variables filesystem $EFIVARFS read-only"; }
    $efipart_mounted && { umount "$EFIPART" || echo "Error: failed to unmount EFI System partition at $EFIPART"; }
}


# Traps
trap -- cleanup EXIT


# Display help
if [[ "$1" =~ ^(-h|--help)$ ]]
then
    shift
    help "$@"
fi

# Check early requirements
require getopt

# Process options
getopt -T &> /dev/null
(( $? != 4 )) && die "your getopt version is too old, get the enhanced getopt from util-linux!"
getopt="$(getopt -n "${0##*/}" -l help,efi,no-efi,grub,no-grub,kernel,no-kernel,modules,no-modules,splash:,no-splash -o +hnegkms -- "$@")" || exit 1
eval set -- "$getopt"
true=true       # trick for -n
negate=false
efi=true
grub=false
kernel=true
modules=true
splash=false
splash_theme="$splash_default_theme"
while true
do
    # Negate if previous option was -n, and reset negation
    $negate && true=false
    negate=false
    case "$1" in
        -h|--help) help ;;
        -n) negate=true ;;
        -e) efi=$true ;;
        --efi) efi=true ;;
        --no-efi) efi=false ;;
        -g) grub=$true ;;
        --grub) grub=true ;;
        --no-grub) grub=false ;;
        -k) kernel=$true ;;
        --kernel) kernel=true ;;
        --no-kernel) kernel=false ;;
        -m) modules=$true ;;
        --modules) modules=true ;;
        --no-modules) modules=false ;;
        -s) splash=$true ;;
        --splash) splash=true; [[ -n "$2" ]] && splash_theme="$2"; shift ;;
        --no-splash) splash=false ;;
        --) shift ; break ;;
        *) die "getopt failure" ;;
    esac
    # Reset trueness
    true=true
    shift
done


# Check requirements
if $kernel
then
    require chmod --kernel
    require mkdir --kernel
    require genkernel --kernel
    require chgrp --kernel
fi
if $grub
then
    require grub2-mkconfig --grub
fi
if $efi
then
    require mountpoint --efi
    require mount --efi
    require umount --efi
    require sed --efi
    require blkid --efi
    require efibootmgr --efi
    require tail --efi
    require mv --efi
    require cp --efi
    [[ "${EFIKERNEL:0:1}" == "/" ]] || die "\$EFIKERNEL must be an absolute path on the EFI System partition: $EFIKERNEL"
fi
if $modules
then
    require grep --modules
    require emerge --modules
    require equery --modules
    require dd --modules
    require base64 --modules
fi
if $splash
then
    require plymouth-set-default-theme --splash
fi

# Check splash settings validity
if $splash
then
    splash_valid=false
    for t in $(plymouth-set-default-theme --list)   # bad
    do
        [[ "$splash_theme" == "$t" ]] && { splash_valid=true; break; }
    done
    $splash_valid || die "invalid splash theme: $splash_theme"
    (( $# > 0 )) && die "unhandled arguments: ${*@Q}"
else
    splash=         # if false, ${splash:+blah} must expand to null
fi


# Build directory
builddir="$KERNELDIR/build"



## Build the kernel
if $kernel
then
    # Ok, let's get paranoid about permissions now. The kernel build below will generate the kernel's signing key for modules, and we don't want these to be world-readable -- or even portage-readable.
    umask="$(umask)"
    echo
    echo "kernel lockdown:"
    verbosedo "kernel lockdown failed" umask 0027
    verbosedo "kernel lockdown failed" chmod 700 "${KERNELDIR%/}/"                  # trailing / is important to chgrp the actual directory and not the symlink (in the KERNELDIR=/usr/src/linux case)
    echo

    # Create the build directory as genkernel fails without it
    mkdir -p "$builddir" || die "build directory creation failed"

    # Build the kernel, with genkernel from sys-kernel/genkernel-next:
    # * save the config in /etc/kernels (--save-config)
    # * assume the config is fine (--no-oldconfig)
    # * clean up, but not too much (--no-mrproper --clean)
    # * don't mount /boot, the real boot filesystem is on /boot/efi (--no-mountboot)
    # * install on /boot and symlink it (--install --symlink)
    # * kernel directory and configuration from the environment (--kerneldir --kernel-config)
    # * separate kernel build directory (--kernel-outputdir)
    # * custom kernel name (--kernname)
    # * build fast (--makeopts)
    # * set the keymap on boot from the kernel command line (--keymap)
    # * fancyness (--plymouth --plymouth-theme)
    # * don't include modules and firmware in the initramfs, it's a custom kernel with all required components built in (--no-ramdisk-modules --no-all-ramdisk-modules --no-firmware)
    # * initramfs components (--busybox --udev --luks --lvm --no-mdadm --no-dmraid)
    # * don't compress the initramfs, but embed it into the kernel (--no-compress-initramfs --integrated-initramfs)
    genkernel --save-config --no-oldconfig --no-mrproper --clean --no-mountboot --install --symlink --kerneldir="$KERNELDIR" --kernel-config="$KERNELCONF" --kernel-outputdir="$builddir" --kernname="cobalt" --makeopts="-j8 -l9" --keymap ${splash:+--plymouth --plymouth-theme="$splash_theme"} --no-ramdisk-modules --no-all-ramdisk-modules --no-firmware --busybox --udev --luks --lvm --no-mdadm --no-dmraid --no-compress-initramfs --integrated-initramfs all || die "kernel build failed"

    # Fine, now let's loosen the restrictions a bit so that portage can still build external modules -- but keep the keys locked
    echo
    echo "kernel partial unlock:"
    verbosedo "kernel unlock failed" chgrp -R portage "${KERNELDIR%/}/"             # trailing / is important to chgrp the actual directory and not the symlink (in the KERNELDIR=/usr/src/linux case)
    verbosedo "kernel unlock failed" chgrp root "$builddir"/certs/signing_key.*
    verbosedo "kernel unlock failed" chmod 600 "$builddir"/certs/signing_key.*
    verbosedo "kernel unlock failed" chmod 750 "${KERNELDIR%/}/"                    # trailing / is important to chgrp the actual directory and not the symlink (in the KERNELDIR=/usr/src/linux case)
    verbosedo "kernel unlock failed" umask "$umask"
fi

# Get the version number
kernelversionfile="$builddir/include/config/kernel.release"
kernelversion="$(<"$kernelversionfile")" 2>/dev/null || die "read kernel version from $kernelversionfile failed"


## Update Grub
if $grub
then
    echo
    echo
    if [[ -f "$GRUBCFG" ]]
    then
        grub2-mkconfig -o "$GRUBCFG" || die "GRUB configuration failed"
    else
        echo "Warning: cannot update Grub: '$GRUBCFG' not found" >&2
    fi
fi


## Install to EFI
if $efi
then
    echo

    # Get information on the EFI system partition
    if ! mountpoint -q "$EFIPART"
    then
        mount "$EFIPART" || die "failed to mount EFI System partition at $EFIPART"
        efipart_mounted=true
        echo "Mounted EFI System partition: $EFIPART"
    fi
    efinode="$(mountpoint -d "$EFIPART")" || die "failed to mount EFI System partition at $EFIPART"
    IFS=: read -r efimajor efiminor <<<"$efinode" || die "can't get EFI System partition major/minor numbers"
    [[ -d /sys/dev/block/"$efinode" ]] || die "EFI System partition is not a block device"
    efidisk=/dev/"$(sed -n -e 's/^DEVNAME=//p' /sys/dev/block/"$efimajor":0/uevent)"
    efiuuid="$(blkid -s PARTUUID -o value "${efidisk}${efiminor}")"
    efipath="${EFIPART}${EFIKERNEL}"
    [[ -n "$EFIOLDKERNEL" ]] && efioldpath="${EFIPART}${EFIOLDKERNEL}"

    # Ensure the EFI variables filesystem is mounted read-write
    IFS=, read -a efivarfsopts <<<"$(mount | sed -n -e 's/^'"$EFIVARFS"' on [^ ]\+ type efivarfs (\([^)]\+\))$/\1/p')"
    (( ${#efivarfsopts[@]} != 0 )) || die "EFI variables filesystem not mounted as $EFIVARFS"
    efivarfs_access=
    for opt in "${efivarfsopts[@]}"
    do
        case "$opt" in
            ro|rw) efivarfs_access="$opt" ;;
        esac
    done
    case "$efivarfs_access" in
        ro) mount -o remount,rw "$EFIVARFS" || die "failed to remount EFI variables filesystem read-write: $EFIVARFS"
            echo "Remounted EFI variables filesystem read-write: $EFIVARFS"
            ;;
        rw) ;;
        *) die "can't determine access mode (ro/rw) for EFI variables filesystem: $EFIVARFS" ;;
    esac

    # Set up an EFI boot entry
    echo
    echo "Setting up EFI boot entry:"
    regex='s/^Boot\([0-9a-fA-F]\{4\}\)\(\*\?\)[[:space:]]\+\(.*\)[[:space:]]\+HD(\([^)]\+\))\/File(\([^)]\+\)).*/\1 a:\2 \4 \5 \3/p'    # regex rundown: "Boot" + 4-digit hex number + "*" if active + label + "HD(" + hd info + ")/File(" + path + ")"
    badlabel=()
    inactive=()
    valid=()
    while read -r bootnum active hd file label
    do
        # Check UUID and path
        IFS=, read -r dummy dummy uuid dummy dummy <<<"$hd"
        [[ "$uuid" == "$efiuuid" ]] || continue
        [[ "$file" == "${EFIKERNEL//\//\\}" ]] || continue
        echo "  * ${bootnum}${active#a:}: \"$label\" HD($hd)/File($file)"
        # Check label
        [[ "$label" == "$EFILABEL" ]] || { badlabel+=("$bootnum"); continue; }
        # Check active
        [[ "$active" == "a:*" ]] && valid+=("$bootnum") || inactive+=("$bootnum")
    done <<<"$(efibootmgr -v | sed -n -e "$regex")"
    if (( ${#valid[*]} > 1 ))
    then
        # It must be okay
        echo "Found multiple valid EFI boot entries: ${valid[*]}"
    elif (( ${#valid[*]} == 1 ))
    then
        # Neat
        echo "Found valid EFI boot entry: ${valid[*]}"
    elif (( ${#inactive[*]} >= 1 ))
    then
        # It's not great, but still okay
        echo "############################################"
        echo "# All valid EFI boot entries are *inactive*: ${inactive[*]}"
        echo "############################################"
    elif (( ${#badlabel[*]} >= 1 ))
    then
        # Uh oh, is there already something else using this path?
        die "matching EFI boot entries have *bad labels*: ${badlabel[*]}"
    else
        # Fine, let's do this
        echo "Warning: no matching EFI boot entry, creating one" >&2
        entries="$(efibootmgr -v --create --disk "$efidisk" --part "$efiminor" --loader "${EFIKERNEL//\//\\}" --label "$EFILABEL")" || die "create EFI boot entry failed"
        read -r bootnum active hd file label <<<"$(tail -n1 <<<"$entries" | sed -n -e "$regex")"
        echo "  * ${bootnum}${active#a:}: \"$label\" HD($hd)/File($file)"
    fi

    # Install the new kernel to the EFI System partition
    echo
    echo "Installing kernel to EFI System partition:"
    if [[ -n "$efioldpath" ]]
    then
        if [[ -f "$efipath" ]]
        then
            verbosedo "backup current EFI kernel failed" mv -fT "$efipath" "$efioldpath"
        else
            skipmsg="Skipped backup of $efipath: no previous kernel at $efipath"
        fi
    else
        skipmsg="Skipped backup of $efipath: empty \$EFIOLDKERNEL"
    fi
    verbosedo "install new EFI kernel failed" cp -fLT "/boot/kernel-$(uname -n)-$(uname -m)-$kernelversion" "$efipath"
    [[ -n "$skipmsg" ]] && echo "$skipmsg"

    # Restore access mode for the EFI variables filesystem
    if [[ "$efivarfs_access" == ro ]]
    then
        efivarfs_access=
        echo
        newlined=true
        mount -o remount,ro "$EFIVARFS" || die "failed to remount EFI variables filesystem read-only: $EFIVARFS"
        echo "Remounted EFI variables filesystem read-only: $EFIVARFS"
    fi

    # Unmount the EFI system partition
    if $efipart_mounted
    then
        efipart_mounted=false
        [[ -z "$newlined" ]] && echo
        umount "$EFIPART" || die "failed to unmount EFI System partition at $EFIPART"
        echo "Unmounted EFI System partition: $EFIPART"
    fi
fi


## Build external modules
if $modules
then
    # Emerge external modules
    echo
    echo
    # Find out whether we're building a PaX kernel and adjust USE flags accordingly
    export USE=-pax_kernel
    grep -q '^CONFIG_PAX=y$' "$KERNELCONF" && USE=pax_kernel
    # The linux-mod/linux-info eclasses need KERNEL_DIR/KBUILD_OUTPUT to use the right kernel and build directory
    KERNEL_DIR="$KERNELDIR" KBUILD_OUTPUT="$builddir" emerge --quiet-build y --keep-going "${EMERGEOPTS[@]}" @module-rebuild || die "emerge modules failed"

    # Sign the modules
    echo
    echo
    echo "Signing modules:"
    sigtext="~Module signature appended~"
    count=0
    for module in $(equery f $(equery b "/lib/modules/$kernelversion") | grep '^/lib/modules/'"${kernelversion//./\\.}"'/.*\.ko$')
    do
        (( count++ ))
        echo -n "$module "
        # Look for "~Module signature appended~" at the end of the file
        # (use `base64` to prevent Bash from choking on null bytes)
        if [[ "$(dd if="$module" iflag=skip_bytes skip="$(($(stat -c %s "$module") - ${#sigtext} - 1))" status=none | base64)" == "$(base64 <<<"$sigtext")" ]]
        then
            echo "ALREADY SIGNED"
        else
            "$builddir/scripts/sign-file" sha512 "$builddir/certs/signing_key.pem" "$builddir/certs/signing_key.x509" "$module" && echo OK || echo FAIL
        fi
    done
    echo "$count modules signed."
fi

echo
